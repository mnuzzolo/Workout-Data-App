//
//  WorkoutSummary.swift
//  Future
//

import Foundation

/// This is the outcome of the workout, generated by the user as they workout
public struct WorkoutSummary: Codable, Equatable, Identifiable {
    public var id: String?
    public var workoutID: String
    public var startedAt: Date?
    public var completedAt: Date?
    public var actualDuration: Int?
    public var activeEnergyBurned: Int?
    public var basalEnergyBurned: Int?
    public var averageHeartRate: Int?
    public var maxHeartRate: Int?
    public var difficulty: Float?
    public var notes: String?
    public var setSummaries: [ExerciseSetSummary] = []
    
    public enum CodingKeys: String, CodingKey {
        case id = "id"
        case workoutID = "workout_id"
        case startedAt = "started_at"
        case completedAt = "completed_at"
        case actualDuration = "actual_duration"
        case activeEnergyBurned = "active_energy_burned"
        case basalEnergyBurned = "basal_energy_burned"
        case averageHeartRate = "average_heart_rate"
        case maxHeartRate = "max_heart_rate"
        case difficulty = "difficulty"
        case notes = "notes"
        case setSummaries = "set_summaries"
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.id = try container.decodeIfPresent(String.self, forKey: .id)
        self.workoutID = try container.decode(String.self, forKey: .workoutID)
        self.startedAt = (try container.decodeIfPresent(String.self, forKey: .startedAt))?.asDate()
        self.completedAt = (try container.decodeIfPresent(String.self, forKey: .completedAt))?.asDate()
        self.actualDuration = try container.decodeIfPresent(Int.self, forKey: .actualDuration)
        self.activeEnergyBurned = try container.decodeIfPresent(Int.self, forKey: .activeEnergyBurned)
        self.basalEnergyBurned = try container.decodeIfPresent(Int.self, forKey: .basalEnergyBurned)
        self.averageHeartRate = try container.decodeIfPresent(Int.self, forKey: .averageHeartRate)
        self.maxHeartRate = try container.decodeIfPresent(Int.self, forKey: .maxHeartRate)
        self.difficulty = try container.decodeIfPresent(Float.self, forKey: .difficulty)
        self.notes = (try container.decodeIfPresent(String.self, forKey: .notes)).nilIfEmpty
        self.setSummaries = try container.decodeIfPresent([ExerciseSetSummary].self, forKey: .setSummaries) ?? []
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encodeIfPresent(self.id, forKey: .id)
        try container.encode(self.workoutID, forKey: .workoutID)
        try container.encodeIfPresent(self.startedAt?.asString(), forKey: .startedAt)
        try container.encodeIfPresent(self.completedAt?.asString(), forKey: .completedAt)
        try container.encodeIfPresent(self.actualDuration, forKey: .actualDuration)
        try container.encodeIfPresent(self.activeEnergyBurned, forKey: .activeEnergyBurned)
        try container.encodeIfPresent(self.basalEnergyBurned, forKey: .basalEnergyBurned)
        try container.encodeIfPresent(self.averageHeartRate, forKey: .averageHeartRate)
        try container.encodeIfPresent(self.maxHeartRate, forKey: .maxHeartRate)
        try container.encodeIfPresent(self.difficulty, forKey: .difficulty)
        try container.encodeIfPresent(self.notes, forKey: .notes)
        try container.encodeIfPresent(self.setSummaries, forKey: .setSummaries)
    }
}

// Helpers
extension WorkoutSummary {
    
    public func setSummariesFor(exerciseSetID: String) -> [ExerciseSetSummary] {
        var setSummaries: [ExerciseSetSummary] = []
        
        for setSummary in self.setSummaries {
            if setSummary.exerciseSetID == exerciseSetID {
                setSummaries.append(setSummary)
            }
        }
        
        return setSummaries
    }
    
}

extension Array where Element == WorkoutSummary {
    
    public func sortedByStartedAtDate() -> [WorkoutSummary] {
        return self.sorted(by: { ($0.startedAt ?? Date.distantPast) <= ($1.startedAt ?? Date.distantPast) })
    }
    
}
